<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>拓展欧几里得算法</title>
    <link href="/2022/09/20/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/20/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p> 扩展欧几里得算法</p><span id="more"></span><p>今天在做作业时遇到了一个问题，关于通过拓展欧几里得算法来求得乘法逆元。</p><p>在翻书的时候，发现书上的扩欧是这样写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">egcd</span>(<span class="hljs-params">a,b</span>):<br>    r0,r1,s0,s1=<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(b):<br>    q,a,b=a/b,b,a%b<br>    r0,r1=r0,r0-q*r1<br>    s0,s1=s1,s0-q*s1<br><span class="hljs-keyword">return</span> a,r0,s0<br></code></pre></td></tr></table></figure><p>很直观地实现了手写时的矩阵形式</p><p>先写成</p><p>$a<em>1+b</em>0=a\a<em>0+b</em>1=b$</p><p>的格式</p><p>在对矩阵最右的$a,b$进行$a-a/b$的运算，用第一行减去第二行作为新的第二行，原来的第二行就变为新的第一行。</p><p>即代码中的$r0=r1,r1=r0-q<em>r1$便是第一行变为第二行，直观点来看就是原本是$1,0$的$r0=1,r1=0;r0=0,r1=1-q</em>0$得到$0,1$，这不就是开始时的第二行吗；</p><p>那么下一步的$s0=s1.s1=s0-q*s1$也是同理。</p><p>这样子算得到的结果没有问题，那如果继续下一步的话运算就会出问题……（未完待续）</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.19 第二次作业</title>
    <link href="/2022/09/19/9-19-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
    <url>/2022/09/19/9-19-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p>   第二次作业</p><span id="more"></span><p>7.手动计算（不知道是应该写在纸上照片拍上来还是应该用md写）</p><p>(a).</p><script type="math/tex; mode=display">\left|\begin{matrix}1 & 0 & 11\\0 & 1 & 5\\\end{matrix}\right|</script><p>下一步是</p><script type="math/tex; mode=display">\left|\begin{matrix}0 & 1 & 5\\1 & -2 & 1\\\end{matrix}\right|</script><p>此时$d=1$，那么就可以得到$1<em>11+(-2)</em>5=1$,那么$a$ 的乘法逆元就是-2；</p><p>(b).</p><p>同上易得：</p><script type="math/tex; mode=display">\left|\begin{matrix}1&0&121\\0&1&13\\\end{matrix}\right|</script><script type="math/tex; mode=display">\left|\begin{matrix}0&1&13\\1&-9&4\\\end{matrix}\right|</script><script type="math/tex; mode=display">\left|\begin{matrix}1&-9&4\\-3&28&1\\\end{matrix}\right|</script><p>可得$a$的乘法逆元是28；</p><p>(c).</p><script type="math/tex; mode=display">\left|\begin{matrix}1&0&1021\\0&1&131\\\end{matrix}\right|</script><script type="math/tex; mode=display">\left|\begin{matrix}29&-70&3\\-34&81&1\\\end{matrix}\right|</script><p>可得$a$的乘法逆元是81。</p><p>8.</p><p>根据书后的解释，将模指数进行分治计算，再将每一部分计算结果乘起来，再用乘积取模，将这一思路用C++表示出来如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Modular</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//将整数转换为二进制数</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(y&gt;<span class="hljs-number">1</span>)<br>        &#123;<br>            a[i]=y%<span class="hljs-number">2</span>;<br>            y=y/<span class="hljs-number">2</span>;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>||y==<span class="hljs-number">1</span>)<br>        &#123;<br>            a[i]=y;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> modular=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> t,r,mode;<br>    <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)<br>    &#123;<br>       <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">1</span>)<span class="hljs-comment">//进行分治运算，二进制字节满足1的进行有效运算</span><br>       &#123;<br><br>           t=<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);<br>           n=<span class="hljs-built_in">pow</span>(x,t);<br>           mode=n%m;<br>           modular=modular*mode;<span class="hljs-comment">//将运算结果乘起来</span><br>       &#125;<br>       i--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> modular%m;<span class="hljs-comment">//用乘积再取一次模</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x,y,m;<br>    <span class="hljs-type">int</span> modular;<br>    cin&gt;&gt;x&gt;&gt;y&gt;&gt;m;<br>    modular=<span class="hljs-built_in">Modular</span>(x,y,m);<br>    cout&lt;&lt;modular&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看得出来这就是我们熟知的快速幂运算。</p><p>3.</p><p>由公式可得：（翻了好久线代……）</p><script type="math/tex; mode=display">\left|\begin{matrix}1&1\\1&0\\\end{matrix}\right|^{n-1}\left|\begin{matrix}F(1)\\F(0)\\\end{matrix}\right|=\left|\begin{matrix}F(n)\\F(n-1)\\\end{matrix}\right|</script><p>那么问题就变成了对矩阵的快速幂问题了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi</span>(<span class="hljs-params">a, b</span>):  <span class="hljs-comment"># 计算二阶矩阵的相乘</span><br>    c = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]  <span class="hljs-comment"># 定义一个空的二阶矩阵</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):  <span class="hljs-comment"># 新二阶矩阵的值计算</span><br>                c[i][j] = c[i][j] + a[i][k] * b[k][j]<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">matrix</span>(<span class="hljs-params">n</span>):<br>    base = [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]  <span class="hljs-comment"># 元矩阵，这里可以把元矩阵看做是2**0=1</span><br>    ans = [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]  <span class="hljs-comment"># 结果矩阵  最开始的结果矩阵也可以看做是1，因为这个矩阵和任意二阶A矩阵相乘结果都是A</span><br>    <span class="hljs-keyword">while</span> n:<br>        <span class="hljs-keyword">if</span> n &amp; <span class="hljs-number">1</span>:  <span class="hljs-comment"># 取n的二进制的最后一位和1做与运算，如果最后一位是1，则进入if体内部</span><br>            ans = multi(ans, base)  <span class="hljs-comment"># 如果在该位置n的二进制为1，则计算ans和base矩阵</span><br>        base = multi(base, base)  <span class="hljs-comment"># base矩阵相乘，相当于初始base矩阵的幂*2</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>  <span class="hljs-comment"># n的二进制往右移一位</span><br>    <span class="hljs-keyword">return</span> ans[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]  <span class="hljs-comment"># 最后获取到的二阶矩阵的[0][1]即f(n)的值</span><br>n=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Matrix:&quot;</span>,matrix(n))<br></code></pre></td></tr></table></figure><p> 这个也算是经典问题了</p><p>那么下面再给出用C编写的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mod 10000</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span></span><br><span class="hljs-class">        &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ma[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<span class="hljs-comment">//用结构体表示矩阵</span><br>        &#125;;<br>Matrix <span class="hljs-title function_">mul</span><span class="hljs-params">(Matrix A,Matrix B)</span><br>&#123;<br>    Matrix C;<br>    C.ma[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=C.ma[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=C.ma[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=C.ma[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//用中间变量矩阵C来储存运算结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">2</span>;k++)<br>            &#123;<br>                C.ma[i][j]=(C.ma[i][j]+A.ma[i][k]*B.ma[k][j])%mod;<span class="hljs-comment">//矩阵相乘</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br>Matrix <span class="hljs-title function_">pow_mod</span><span class="hljs-params">(Matrix A,<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span><br>&#123;<br>    Matrix B;<br>    B.ma[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=B.ma[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//化为单位矩阵</span><br>    B.ma[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=B.ma[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) B=mul(B,A);<span class="hljs-comment">//进行幂的操作</span><br>        A=mul(A,A);<br>        n&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-comment">//二进制数n右移一位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> B;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n)&amp;&amp;n!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        Matrix A;<br>        A.ma[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;A.ma[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//斐波那契数列的目标矩阵</span><br>        A.ma[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;A.ma[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        Matrix ans=pow_mod(A,n);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans.ma[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);<span class="hljs-comment">//由公式可知，如果运行n次的话，第一列第二行的结果就是F(n)</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.</p><p>假设$a$和$b$是$m$的逆元，则$bc\equiv ac\equiv 1(mod~m)$。</p><p>由定理可得：$m|c(b-a)$，又因为$gcd(c,m)=1$，所以$m|(b-a)$，即$b\equiv a(mod~m)$。</p><p>说明$b$和$a$是$m$唯一的逆元，与假设矛盾。</p><p>综上所述，对于两个互素的$c$和$m$，满足$gcd(c,m)=1$，那么$c$模$m$的逆元是唯一的。</p><p>5.</p><p>已知整数$a$、$b$，扩展欧几里得算法可以在求得$a$、$b$的最大公约数的同时，能找到整数$x$、$y$（其中一个很可能是负数），使它们满足贝祖等式<br>$ax+by=gcd(a,b)$</p><p>如果a是负数，可以把问题转化成$∣ a ∣ ( − x ) + b y = g c d ( ∣ a ∣ , b ) |a|(-x)+by=gcd(|a|,b)∣a∣(−x)+by=gcd(∣a∣,b)，然后令x’=(-x)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ext_gcd</span>(<span class="hljs-params">a, b</span>):   <span class="hljs-comment">#扩展欧几里得算法</span><br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, a<br>    <span class="hljs-keyword">else</span>:<br>        x, y, gcd = ext_gcd(b, a % b)   <span class="hljs-comment">#递归直至余数等于0(需多递归一层用来判断)</span><br>        x, y = y, (x - (a // b) * y)   <span class="hljs-comment">#辗转相除法反向推导每层a、b的因子使得gcd(a,b)=ax+by成立</span><br>        <span class="hljs-keyword">return</span> x, y, gcd<br></code></pre></td></tr></table></figure><p>那么返回值$y$就是所求逆元。</p>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制欧几里得算法</title>
    <link href="/2022/09/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>欧几里得算法</title>
    <link href="/2022/09/06/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/06/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>​    <span id="more"></span></p><p>先给出欧几里得算法的定理：</p><p>给定两个整数a和b，设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="5.185ex" height="1.882ex" role="img" focusable="false" viewBox="0 -694 2291.6 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1862.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container>，则a和b的最大公因子等于b和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="7.559ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 3341 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mtext" transform="translate(529,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(779,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1657,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(2142,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mtext" transform="translate(2662,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(2912,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container>的最大公因子。即</p><script type="math/tex; mode=display">gcd(a,b)=gcd(b,a~mod~b)</script><p>其中，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="7.559ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 3341 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mtext" transform="translate(529,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(779,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1657,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(2142,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mtext" transform="translate(2662,0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(2912,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g></g></g></svg></mjx-container> 表示用a除以b所得的余数r。</p><p>下面给出欧几里得算法的递归实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">"输入a"</span>))<br>b=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">"输入b"</span>))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> a<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> gcd(b,a%b)<br><br><span class="hljs-built_in">print</span>(gcd(a,b))<br></code></pre></td></tr></table></figure><p>欧几里得算法的迭代实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">"输入a"</span>))<br>b=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">"输入b"</span>))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span> a<br>    <span class="hljs-keyword">while</span>(a&gt;<span class="hljs-number">0</span>):<br>        c=a%b;a=b;b=c;<br>        <span class="hljs-keyword">return</span> a<br><br><span class="hljs-built_in">print</span>(gcd(a,b))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>CINTA学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.29 Chapter1 1.1 homework</title>
    <link href="/2022/08/29/8-29-Chapter1-1-1-homework/"/>
    <url>/2022/08/29/8-29-Chapter1-1-1-homework/</url>
    
    <content type="html"><![CDATA[<p>​    第一节课</p><span id="more"></span><p>第一题：</p><p>正常我们判断一个数的奇偶是看这个数能不能被二整除，运用这个思路写的程序就只要求数m满足m%2==0即可完成；</p><p>在学习了二进制性质一之后，我们有了一个新思路，即判断数m的二进制形式的最后一个比特是0还是1，来确定它的奇偶。但转念一想。哎……那这不是一个意思吗？</p><p>那题解就如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    <span class="hljs-keyword">if</span>(m%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(m%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><!--more--><p>第三题</p><p>根据今天上课学到的迭代乘法式，用C++语言表示出来</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br>using namespace std;<br>int main()<br>&#123;<br>    int m,i,n,t,l;<br>    int a[10];<br>    cin&gt;&gt;n&gt;&gt;m;<br>    int <span class="hljs-attribute">b</span>=0;<br>    int <span class="hljs-attribute">num</span>=0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-attribute">i</span>=0;m&gt;0;i++)<br>    &#123;<br>        a[i]=m%2;<br>        <span class="hljs-attribute">m</span>=m/2;<br>        b++;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(int <span class="hljs-attribute">j</span>=i;j&gt;=0;j--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[j]==1)<br>        &#123;<br>            <span class="hljs-attribute">t</span>=pow(2,j);<br>            <span class="hljs-attribute">l</span>=n*t;<br>            num+=l;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;num&lt;&lt;endl;<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><!--more--><p>第四题</p><p>证明命题1.1<br>证明过程：<br>首先证明前半部分：根据a | b，b | c，设b=qa，c=pb，其中q,p∈ Z。则c=p<em>(qa)=pq</em>a。由于p∈ Z，q∈ Z，因此p,q∈ Z。所以 c | a得证。</p><p>证明后半部分：<br>根据c | a，c | b，设a=qc，b=pc，其中q,p∈ Z。则(ma+nb)/c<br>=ma/c+nb/c<br>=mqc/c+npc/c<br>=mq+np.<br>即ma+nb=(mq+np)c。<br>由于q,p∈ Z，m, n ∈ Z，因此mq,np∈ Z。所以c | (ma + nb)得证。</p>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex</title>
    <link href="/2022/07/25/LaTex/"/>
    <url>/2022/07/25/LaTex/</url>
    
    <content type="html"><![CDATA[<script type="math/tex; mode=display">a^3+b^3=c^3</script><p>好耶！</p><span id="more"></span><p>在第一次完成公式的时候，我打开blog看看帖子的效果，发现并不像我在编辑器里打出的LaTex语句一样，而是把我本来的语句显示出来，在一番搜索之后，发现hexo的渲染器不支持LaTex的语句，于是在进行一系列的修改后，将hexo的渲染器改成了Katex，就可以成功显示LaTex语句了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>判断素数</title>
    <link href="/2022/07/25/%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/"/>
    <url>/2022/07/25/%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>​    简单题</p><span id="more"></span><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<iostream></h1><p>using namespace std;<br>void prime(int a)<br>{<br>    if(a==1)<br>    cout&lt;&lt;”not prime”;<br>    else if(a==2||a==3)<br>    cout&lt;&lt;”prime”;<br>    else<br>    for(int i=2;i&lt;=a/2;i++)<br>    {<br>        if(a%i==0)<br>        {<br>            cout&lt;&lt;”not prime”;<br>            break;<br>        }<br>        else if(i==a/2)<br>        cout&lt;&lt;”prime”;<br>    }<br>}<br>int main()<br>{<br>    int n;<br>    cin&gt;&gt;n;<br>    prime(n);<br>    return 0;<br>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制数</title>
    <link href="/2022/07/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <url>/2022/07/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>​    简单题</p><span id="more"></span><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><p>using namespace std;<br>int main()<br>{<br>    int a[1000];<br>    int i=0;<br>    int m,n;<br>    cin&gt;&gt;m;<br>    while(1)<br>    {<br>        if(m&gt;1)<br>        {<br>            a[i]=m%2;<br>            m=m/2;<br>            i++;<br>        }<br>        if(m==0||m==1)<br>        {<br>            a[i]=m;<br>            break;<br>        }<br>    }<br>    for(int j=i;i&gt;=0;i—)<br>    {<br>        cout&lt;&lt;a[i];<br>    }<br>    return 0;<br>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2022/07/15/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/07/15/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>（这是第一次写的作业）</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">插入排序。注意，若后面一个元素比其前面一个元素小，则将这两个元素交换位置，然后再来比较这个插入元素与前面一个元素的大小，若小，则还需要交换这两个元素位置，一直到这个插入元素在正确的位置为止</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],  <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j + <span class="hljs-number">1</span>] &lt; a[j]; j--)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(a[j], a[j + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[] = &#123; <span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span> &#125;;<br><br>    <span class="hljs-built_in">insertSort</span>(a, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot;&quot;</span>;<br><br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入排序的代码大概就是这样罢……</p>]]></content>
    
    
    
    <tags>
      
      <tag>-作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/10/hello-world/"/>
    <url>/2022/07/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
